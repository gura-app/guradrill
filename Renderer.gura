#!/usr/bin/env gura
import(re)
import(cairo)
import(utils)
import(units)

//------------------------------------------------------------------------------
// forward-declaration
//------------------------------------------------------------------------------
Item = class()

//------------------------------------------------------------------------------
// Extent
//------------------------------------------------------------------------------
Extent = struct(x_advance:number, ascent:number, descent:number)

//------------------------------------------------------------------------------
// Canvas
//------------------------------------------------------------------------------
Canvas = class {
	__init__(cr:cairo.context) = {
		this.cr:public = cr
		this.fontFamilyName = 'Helvetica'
		//this.fontFamilyName = 'Times New Roman'
		this.fontSize = 7.0
		this.cr.select_font_face(this.fontFamilyName,
								 cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
		this.cr.set_font_size(this.fontSize)
		this.x = this.y = 0
		this.xTop = 0
	}
	CreateForPreview(magScale:number):static = {
		scale = magScale * 4
		this.img = image(`rgba, 210 * scale, 297 * scale, '#eeeeee')
		cr = this.img.cairo()
		cr.scale(scale, scale)
		Canvas(cr)
	}
	CreateForPDF(fileName:string):static = {
		scale = 72 / 25.4
		cr = cairo.create(cairo.pdf_surface.create(fileName, 210 * scale, 297 * scale))
		cr.scale(scale, scale)
		Canvas(cr)
	}
	Flush() = {
		this.cr.destroy()
	}
	GetImage() = this.img
	SetPosition(x:number, y:number) = {
		this.x = x, this.y = y
		this.xTop = x
	}
	SetLineWidth(border:symbol) = {
		width = if (border == `thin) {
			.1
		} elsif (border == `medium) {
			.2
		} else {
			.5
		}
		this.cr.set_line_width(width)
	}
	Save() {block} = {
		fontSizeSaved = this.fontSize
		block()
		this.fontSize = fontSizeSaved
		this.cr.set_font_size(this.fontSize)
	}
	SetFontSmall() = {
		this.cr.set_font_size(this.fontSize * .8)
	}
	SetFontSizeByRatio(ratio:number) = {
		this.fontSize *= ratio
		this.cr.set_font_size(this.fontSize)
	}
	GetWidthEm() = {
		this.cr.text_extents('m').width
	}
	CalcLength(n:number, unit:string) = {
		if (unit == 'em') {
			n * this.GetWidthEm()
		} else {
			n
		}
	}
	GetOffsetCenter() = {
		-this.cr.text_extents('0').y_bearing / 2
	}
	DrawBox(x:number, y:number, width:number, height:number, border:symbol) = {
		this.cr.rectangle(x, y, width, height)
		this.SetLineWidth(border)
		this.cr.stroke()
	}
	DrawText(x:number, y:number, text:string, drawFlag:boolean => true) = {
		textExt = this.cr.text_extents(text)
		if (drawFlag) {
			this.cr.move_to(x, y)
			this.cr.show_text(text)
		}
		Extent(textExt.x_advance, -textExt.y_bearing, textExt.height + textExt.y_bearing)
	}
	DrawSymbol(x:number, y:number, text:string, drawFlag:boolean => true) = {
		textExt = this.cr.text_extents(text)
		offsetCenter = this.GetOffsetCenter()
		ascent = offsetCenter + textExt.height / 2
		descent = max(0, textExt.height - ascent)
		if (drawFlag) {
			fontExt = this.cr.font_extents()
			this.cr.move_to(x, y - offsetCenter - textExt.y_bearing - textExt.height / 2)
			this.cr.show_text(text)
		}
		Extent(textExt.x_advance, ascent, descent)
	}
	DrawItem(x:number, y:number, item:Item, drawFlag:boolean => true) = {
		item.Draw(this, x, y, drawFlag)
	}
	DrawItems(x:number, y:number, items[]:Item, drawFlag:boolean => true) = {
		x0 = x
		ascent = descent = 0
		items.each {|item|
			ext = this.DrawItem(x, y, item, drawFlag)
			if (ascent < ext.ascent) {ascent = ext.ascent}
			if (descent < ext.descent) {descent = ext.descent}
			x += ext.x_advance
		}
		Extent(x - x0, ascent, descent)
	}
	CalcExtentItem(item:Item) = this.DrawItem(0, 0, item, false)
	CalcExtentItems(items[]:Item) = this.DrawItems(0, 0, items, false)
	Render(content:string) = {
		ext = this.DrawItem(this.x, this.y, Parse(content))
		this.x += ext.x_advance
	}
	Newline(mag:number => 1) = {
		fontExt = this.cr.font_extents()
		this.x = this.xTop
		this.y += fontExt.height * mag
	}
	FoldHorz(items[]:Item, width:number) {block} = {
		itemsFold = []
		wdAccum = 0
		descentPrev = 0
		ascent = descent = 0
		items.each {|item|
			ext = this.CalcExtentItem(item)
			if (wdAccum + ext.x_advance > width) {
				block(itemsFold, descentPrev + ascent)
				itemsFold.clear()
				wdAccum = 0
				descentPrev = descent
				ascent = descent = 0
			}
			wdAccum += ext.x_advance
			itemsFold.add(item)
			if (ascent < ext.ascent) {ascent = ext.ascent}
			if (descent < ext.descent) {descent = ext.descent}
		}
		block(itemsFold, descentPrev + ascent)
	}
}

//------------------------------------------------------------------------------
// Item
//------------------------------------------------------------------------------
Item = class {
	__init__(type:symbol, itemParent:Item:nil) = {
		this.type:public = type
		this.itemParent:public = itemParent
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {}
	AddChildTo(itemStack[]:Item, item:Item):void:static = {
		itemParent = itemStack.last()
		itemParent.AddChild(item)
		if (itemParent.type in [`Rational, `Power] && itemParent.children.len() >= 2) {
			itemStack.erase(-1)
		} elsif (itemParent.type in [`Sqrt] && itemParent.children.len() >= 1) {
			itemStack.erase(-1)
		}
	}
}

//------------------------------------------------------------------------------
// ItemContainer -> Item
//------------------------------------------------------------------------------
ItemContainer = class(Item) {
	__init__(type:symbol, itemParent:Item:nil) = {|type, itemParent|
		this.children:public = []
	}
	AddChild(item:Item) = this.children.add(item)
	GetLastChild() = if (!this.children.isempty()) {this.children.last()}
	EraseLastChild() = this.children.erase(-1)
}

//------------------------------------------------------------------------------
// ItemRoot -> ItemContainer
//------------------------------------------------------------------------------
ItemRoot = class(ItemContainer) {
	__init__() = {|`Root, nil|}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		canvas.DrawItems(x, y, this.children, drawFlag)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:\n', indentLevel * 2, '', this.type)
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemBox -> ItemContainer
//------------------------------------------------------------------------------
ItemBox = class(ItemContainer) {
	__init__(itemParent:Item) = {|`Box, itemParent|
		this.pack:public		= nil
		this.width:public		= nil
		this.widthUnit:public	= nil
		this.height:public		= nil
		this.heightUnit:public	= nil
		this.align:public		= nil
		this.valign:public		= nil
		this.border:public		= nil
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		if (!this.pack) {
			this.DrawInline(canvas, x, y, drawFlag)
		} elsif (this.pack == `horz) {
			this.DrawPackHorz(canvas, x, y, drawFlag)
		} elsif (this.pack == `vert) {
			this.DrawPackVert(canvas, x, y, drawFlag)
		}
	}
	DrawInline(canvas:Canvas, x:number, y:number, drawFlag:boolean) = {
		if (this.children.isempty()) {
			fontExt = canvas.cr.font_extents()
			ext = Extent(0, fontExt.ascent, 0)
		} else {
			ext = canvas.CalcExtentItems(this.children)
		}
		if (this.width) {
			width = canvas.CalcLength(this.width, this.widthUnit)
		} else {
			width = ext.x_advance
		}
		xOffset = 0, yOffset = 0
		if (this.height) {
			height = canvas.CalcLength(this.height, this.heightUnit)
			offsetCenter = canvas.GetOffsetCenter()
			ascent = height / 2 + offsetCenter
			descent = height / 2 - offsetCenter
		} else {
			ascent = ext.ascent
			descent = ext.descent
		}
		xOffset = if (this.align == `left) {
			0
		} elsif (this.align == `center) {
			(width - ext.x_advance) / 2
		} elsif (this.align == `right) {
			width - ext.x_advance
		} else {
			0
		}
		yOffset = if (this.align == `top) {
			0
		} elsif (this.align == `medium) {
			height / 2 + (ascent - descent) / 2
		} elsif (this.align == `botom) {
			height - ext.descent
		} else {
			0
		}
		canvas.Save {
			canvas.DrawItems(x + xOffset, y + yOffset, this.children, drawFlag)
		}
		if (this.border && drawFlag) {
			canvas.DrawBox(x, y - ascent, width, ascent + descent, this.border)
		}
		Extent(width, ascent, descent)
	}
	DrawPackHorz(canvas:Canvas, x:number, y:number, drawFlag:boolean) = {
		if (this.width) {
			width = canvas.CalcLength(this.width, this.widthUnit)
		} elsif (this.itemParent.type == `Box) {
			width = canvas.CalcLength(this.itemParent.width, this.itemParent.widthUnit)
		} else {
			// error
		}
		if (this.height) {
			height = canvas.CalcLength(this.height, this.heightUnit)
		} elsif (this.itemParent.type == `Box) {
			height = canvas.CalcLength(this.itemParent.height, this.itemParent.heightUnit)
		} else {
			// error
		}
		yOffset = 0
		canvas.Save {
			canvas.FoldHorz(this.children, width) {|itemsFold[]:Item, y_advance:number|
				yOffset += y_advance
				canvas.DrawItems(x, y + yOffset, itemsFold, drawFlag)
			}
		}
		if (this.border && drawFlag) {
			canvas.DrawBox(x, y, width, height, this.border)
		}
		Extent(width, 0, height)
	}
	DrawPackVert(canvas:Canvas, x:number, y:number, drawFlag:boolean) = {
		if (this.width) {
			width = canvas.CalcLength(this.width, this.widthUnit)
		} elsif (this.itemParent.type == `Box) {
			width = canvas.CalcLength(this.itemParent.width, this.itemParent.widthUnit)
		} else {
			// error
		}
		if (this.height) {
			height = canvas.CalcLength(this.height, this.heightUnit)
		} elsif (this.itemParent.type == `Box) {
			height = canvas.CalcLength(this.itemParent.height, this.itemParent.heightUnit)
		} else {
			// error
		}
		yOffset = 0
		descentPrev = 0
		canvas.Save {
			this.children.each {|item|
				ext = canvas.CalcExtentItem(item)
				yOffset += ext.ascent + descentPrev
				canvas.DrawItem(x, y + yOffset, item, drawFlag)
				descentPrev = ext.descent
			}
		}
		Extent(width, 0, height)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:', indentLevel * 2, '', this.type)
		this.pack && printf(' pack=%s', this.pack)
		this.width && printf(' width=%f%s', this.width, this.widthUnit)
		this.height && printf(' height=%f%s', this.height, this.heightUnit)
		this.align && printf(' align=%s', this.align)
		this.border && printf(' border=%s', this.border)
		println()
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemText -> Item
//------------------------------------------------------------------------------
ItemText = class(Item) {
	__init__(itemParent:Item, text:string) = {|`Text, itemParent|
		this.text:public = text
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		canvas.DrawText(x, y, this.text, drawFlag)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s: "%s"\n', indentLevel * 2, '', this.type, this.text)
	}
}

//------------------------------------------------------------------------------
// ItemOperator -> Item
//------------------------------------------------------------------------------
ItemOperator = class(Item) {
	__init__(itemParent:Item, text:string) = {|`Operator, itemParent|
		this.opSymbol:public = if (text == '*') {
			'\u00d7'
		} elsif (text == '%') {
			'\u00f7'
		} elsif (text == '-') {
			'\u2212'
		} else {
			text
		}
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		x0 = x
		widthEm = canvas.GetWidthEm()
		x += widthEm * .4
		ext = canvas.DrawSymbol(x, y, this.opSymbol, drawFlag)
		x += ext.x_advance
		x += widthEm * .4
		Extent(x - x0, ext.ascent, ext.descent)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s: "%s"\n', indentLevel * 2, '', this.type, this.opSymbol)
	}
}

//------------------------------------------------------------------------------
// ItemBracket -> ItemContainer
//------------------------------------------------------------------------------
ItemBracket = class(ItemContainer) {
	__init__(itemParent:Item) = {|`Bracket, itemParent|}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		x0 = x
		widthEm = canvas.GetWidthEm()
		extParenL = canvas.DrawSymbol(x, y, '(', drawFlag)
		x += extParenL.x_advance
		extBody = canvas.DrawItems(x, y, this.children, drawFlag)
		x += extBody.x_advance
		x += widthEm * .1
		extParenR = canvas.DrawSymbol(x, y, ')', drawFlag)
		x += extParenR.x_advance
		Extent(x - x0,
			   max(extParenL.ascent, extBody.ascent, extParenR.ascent),
			   max(extParenL.descent, extBody.descent, extParenR.descent))
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:\n', indentLevel * 2, '', this.type)
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemRational -> ItemContainer
//------------------------------------------------------------------------------
ItemRational = class(ItemContainer) {
	__init__(itemParent:Item) = {|`Rational, itemParent|
		// this.children[] stores two items: itemNumer and itemDenom
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		[itemNumer, itemDenom] = this.children[0, 1]
		widthEm = canvas.GetWidthEm()
		wdStick = widthEm * .5
		htMgn = widthEm * .2
		offsetCenter = canvas.GetOffsetCenter()
		yCenter = y - offsetCenter
		extNumer = canvas.CalcExtentItem(itemNumer)
		extDenom = canvas.CalcExtentItem(itemDenom)
		width = max(extNumer.x_advance, extDenom.x_advance) + wdStick * 2
		canvas.DrawItem(x + (width - extNumer.x_advance) / 2,
					   yCenter - htMgn - extNumer.descent, itemNumer, drawFlag)
		canvas.DrawItem(x + (width - extDenom.x_advance) / 2,
					   yCenter + htMgn + extDenom.ascent, itemDenom, drawFlag)
		if (drawFlag) {
			canvas.cr.move_to(x, yCenter)
			canvas.cr.rel_line_to(width, 0)
			canvas.SetLineWidth(`medium)
			canvas.cr.stroke()
		}
		Extent(width,
			   extNumer.ascent + extNumer.descent + htMgn + extDenom.ascent - offsetCenter,
			   extDenom.descent + offsetCenter + htMgn)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:\n', indentLevel * 2, '', this.type)
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemPower -> ItemContainer
//------------------------------------------------------------------------------
ItemPower = class(ItemContainer) {
	__init__(itemParent:Item) = {|`Power, itemParent|
		// this.children[] stores two items: itemBase and itemPower
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		[itemBase, itemPower] = this.children[0, 1]
		x0 = x
		extBase = canvas.DrawItem(x, y, itemBase, drawFlag)
		x += extBase.x_advance
		canvas.Save {
			canvas.SetFontSizeByRatio(.6)
			yOffset = extBase.ascent * .6
			extPower = canvas.DrawItem(x, y - yOffset, itemPower, drawFlag)
		}
		x += extPower.x_advance
		Extent(x - x0, max(yOffset + extPower.ascent, extBase.ascent), extBase.descent)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:\n', indentLevel * 2, '', this.type)
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemSqrt -> ItemContainer
//------------------------------------------------------------------------------
ItemSqrt = class(ItemContainer) {
	__init__(itemParent:Item) = {|`Sqrt, itemParent|
		// this.children[] stores one item: itemBase
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		widthEm = canvas.GetWidthEm()
		htHead = widthEm * .2
		htTails = [.4, .5] * widthEm
		wdTails = [.1, .2, .3] * widthEm
		wdTail = wdTails.sum()
		wdMgnLeft = widthEm * .2
		wdMgnRight = widthEm * .4
		itemBase = this.children[0]
		extBase = canvas.DrawItem(x + wdTail + wdMgnLeft, y, itemBase, drawFlag)
		ascent = extBase.ascent + htHead
		if (drawFlag) {
			canvas.cr.move_to(x, y + extBase.descent - htTails[0])
			canvas.cr.line_to(x + wdTails[0], y + extBase.descent - htTails[1])
			canvas.cr.line_to(x + wdTails[0..1].sum(), y + extBase.descent)
			canvas.cr.line_to(x + wdTails.sum(), y - ascent)
			canvas.cr.rel_line_to(wdMgnLeft + extBase.x_advance + wdMgnRight, 0)
			canvas.SetLineWidth(`medium)
			canvas.cr.stroke()
		}
		x += extBase.x_advance
		Extent(wdTail + wdMgnLeft + extBase.x_advance + wdMgnRight, ascent, extBase.descent)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s:\n', indentLevel * 2, '', this.type)
		this.children:*Print(indentLevel + 1)
	}
}

//------------------------------------------------------------------------------
// ItemDecorator -> Item
//------------------------------------------------------------------------------
ItemDecorator = class(Item) {
	__init__(itemParent:Item, deco:symbol) = {|`Decorator, itemParent|
		this.deco = deco
	}
	Draw(canvas:Canvas, x:number, y:number, drawFlag:boolean => true) = {
		if (this.deco == `small) {
			canvas.SetFontSmall()
		}
		Extent(0, 0, 0)
	}
	Print(indentLevel:number => 0):void = {
		printf('%*s%s: %s\n', indentLevel * 2, '', this.type, this.deco)
	}
}

//------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------

Parse(content:string) = {
	specialCharDict = %{
		'pi'	=> '\u03c0'
		'infty'	=> '\u221e'
	}
	specialOpDict = %{
		'neq'	=> '\u2260'
		'leq'	=> '\u2266'
		'geq'	=> '\u2267'
		'pm'	=> '\u00b1'
		'mp'	=> '\u2213'
		'simeq'	=> '\u2252'
		'equiv'	=> '\u2261'
	}
	mathModeFlag = true
	itemStack = []
	itemStack.add(ItemRoot())
	text = ''
	stat = `Init
	content.each {|ch|
		utils.pushback {|pb|
			if (stat == `Init) {
				itemParent = itemStack.last()
				if (ch == '{') {
					item = ItemBox(itemParent)
					Item.AddChildTo(itemStack, item)
					itemStack.add(item)
				} elsif (ch == '}') {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						itemParent = itemStack.last()
						text = ''
					}
					if (itemParent.type != `Box) {
						raise(error.SyntaxError, 'unbalanced bracket')
					}
					stat = `BoxAttrPre
				} elsif (ch in [' ', '\t', '\n']) {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						text = ''
					}
				} elsif (ch == '\\') {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						text = ''
					}
					stat = `Command
				} elsif (!mathModeFlag) {
					text += ch
				} elsif (ch == '(') {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						text = ''
					}
					item = ItemBracket(itemParent)
					Item.AddChildTo(itemStack, item)
					itemStack.add(item)
				} elsif (ch == ')') {
					itemParent = itemStack.last()
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						itemParent = itemStack.last()
						text = ''
					}
					if (itemParent.type != `Bracket) {
						raise(error.SyntacError, 'unbalanced bracket')
					}
					itemStack.erase(-1)
					text = ''
				} elsif (ch == '/') {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						itemParent = itemStack.last()
						text = ''
					}
					if (itemLast = itemParent.GetLastChild()) {
						itemParent.EraseLastChild()
						item = ItemRational(itemParent)
						Item.AddChildTo(itemStack, item)
						item.AddChild(itemLast)
						itemStack.add(item)
					}
				} elsif (ch == '^') {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						itemParent = itemStack.last()
						text = ''
					}
					if (itemLast = itemParent.GetLastChild()) {
						itemParent.EraseLastChild()
						item = ItemPower(itemParent)
						Item.AddChildTo(itemStack, item)
						item.AddChild(itemLast)
						itemStack.add(item)
					}
				} elsif (ch in ['+', '-', '*', '%', '=', '<', '>']) {
					if (!text.isempty()) {
						Item.AddChildTo(itemStack, ItemText(itemParent, text))
						text = ''
					}
					Item.AddChildTo(itemStack, ItemOperator(itemParent, ch))
				} else {
					text += ch
				}
			} elsif (stat == `BoxAttrPre) {
				if (ch == '[') {
					stat = `BoxAttr
				} else {
					itemStack.erase(-1)
					pb.Pushback()
					stat = `Init
				}
			} elsif (stat == `BoxAttr) {
				if (ch == ']') {
					itemParent = itemStack.last()
					text.split(',') {|field|
						field = field.strip()
						if (m = field.match(r'pack=([a-z]+)')) {
							if (m[1] in ['horz', 'vert']) {
								itemParent.pack = m[1].tosymbol()
							}
						} elsif (field == 'pack') {
							itemParent.pack = `horz
						} elsif (m = field.match(r'width=([\d\.]+)([a-z]+)')) {
							itemParent.width = m[1].tonumber()
							itemParent.widthUnit = m[2]
						} elsif (m = field.match(r'height=([\d\.]+)([a-z]+)')) {
							itemParent.height = m[1].tonumber()
							itemParent.heightUnit = m[2]
						} elsif (m = field.match(r'border=([a-z]+)')) {
							if (m[1] in ['thin', 'medium', 'thick']) {
								itemParent.border = m[1].tosymbol()
							}
						} elsif (field == 'border') {
							itemParent.border = `medium
						} elsif (m = field.match(r'align=([a-z]+)')) {
							if (m[1] in ['left', 'center', 'right']) {
								itemParent.align = m[1].tosymbol()
							}
						} elsif (m = field.match(r'valign=([a-z]+)')) {
							if (m[1] in ['top', 'middle', 'bottom']) {
								itemParent.valign = m[1].tosymbol()
							}
						} else {
							// invalid attribute
						}
					}
					itemStack.erase(-1)
					text = ''
					stat = `Init
				} else {
					text += ch
				}
			} elsif (stat == `Command) {
				if (ch.isalpha()) {
					text += ch
				} else {
					if (text == 'sqrt') {
						item = ItemSqrt(itemParent)
						Item.AddChildTo(itemStack, item)
						itemStack.add(item)
					} elsif (text in ['small', 'normalsize', 'large', 'it', 'bf']) {
						Item.AddChildTo(itemStack, ItemDecorator(itemParent, text))
					} elsif (chConv = specialCharDict.get(text)) {
						Item.AddChildTo(itemStack, ItemText(itemParent, chConv))
					} elsif (chConv = specialOpDict.get(text)) {
						Item.AddChildTo(itemStack, ItemOperator(itemParent, chConv))
					}
					text = ''
					pb.Pushback()
					stat = `Init
				}
			}
		}
	}
	if (!text.isempty()) {
		itemParent = itemStack.last()
		Item.AddChildTo(itemStack, ItemText(itemParent, text))
	}
	itemStack.first()
}

DrawTextWithBBox(cr:cairo.context, x:number, y:number, str:string) = {
	xOff = 0
	str.each {|ch|
		textExt = cr.text_extents(ch)
		cr.rectangle(x + xOff + textExt.x_bearing, y + textExt.y_bearing,
					 textExt.width, textExt.height)
		xOff += textExt.x_advance
	}
	cr.set_source_rgba(0.8, 0.8, 0.8, 0.7)
	cr.fill()
	
	cr.move_to(x, y)
	cr.set_source_rgba(0.0, 0.0, 0.0, 1.0)
	cr.show_text(str)

	textExt = cr.text_extents(str)
	fontExt = cr.font_extents()
	scope {
		cr.move_to(x, y), cr.rel_line_to(textExt.x_advance, 0)
		cr.set_source_rgba(1.0, 0.2, 0.2, 1.0)
		cr.stroke()
	}
	scope {
		//cr.move_to(x, y + textExt.y_bearing), cr.rel_line_to(textExt.x_advance, 0)
		cr.move_to(x, y -  fontExt.ascent), cr.rel_line_to(textExt.x_advance, 0)
		cr.set_source_rgba(0.2, 1.0, 0.2, 1.0)
		cr.stroke()
	}
	scope {
		//cr.move_to(x, y + textExt.y_bearing + textExt.height), cr.rel_line_to(textExt.x_advance, 0)
		cr.move_to(x, y + fontExt.descent), cr.rel_line_to(textExt.x_advance, 0)
		cr.set_source_rgba(0.2, 0.2, 1.0, 1.0)
		cr.stroke()
	}
}

Compose2(canvas:Renderer.Canvas) = {
	canvas.SetPosition(20, 20)
	canvas.Render(R'''
	{
		${'{' + format(r'{\small (%d)}[width=3em]', 1..) + [
			r'(10 + 30) * 5 % 2 - 7 ='
			r'3 ^ 4 + 2 ^ {3x + 2} + 3 ^ {x ^ 2}'
			r'\sqrt{x^2 + y^2 + z^2}'
			r'3 / 500 + 2 / 3 - {}[width=3em,border] / 10 ='
			r'{10}[width=3em,align=left,border] +' \
			r'{10}[width=3em,align=center,border] +' \
			r'{10}[width=3em,align=right,border]'
			r'3 * 3 * \pi'
			r'\sqrt 7 + \sqrt{3 / 5}'
			r'x = {-b \pm \sqrt{b^2 - 4ac}} / 2a'
			r'\sqrt{x+\sqrt{x+\sqrt{x+1}}}'
		] + '}[pack,width=18em,height=4em]'}
	}[pack,width=40em,height=18em]
	'''.embed())
}

if (__name__ == '__main__') {
	//str = 'x^2+3x^3+4=0'
	//str = '{1000}[5em,center] + {123}[5em,center] = {}[5em,border=thin]'
	//str = '123+345-1111'
	//str = '1 % 3 + {x + 3} % {3x + 2} + 1 % {2 % 3}'
	//str = '1 % {2 % 3}'
	//str = '{1 % 2} % {2 % 3}'
	//str = r'3 * 3 * \pi '
	//str = r'2(10 + 12)'
	//Parse(str).Print()
	canvas = Canvas.CreateForPDF('a.pdf')
	Compose2(canvas)
	canvas.Flush()
}
